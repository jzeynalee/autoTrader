# autoTrader/models.py
import json
from dataclasses import dataclass, field, asdict
from datetime import datetime
from enum import Enum
from typing import Optional, Dict, List, Any, Union

# =============================================================================
# ENUMS (Standardized Constants)
# =============================================================================

class TradeDirection(str, Enum):
    LONG = "LONG"
    SHORT = "SHORT"

class OrderSide(str, Enum):
    BUY = "buy"
    SELL = "sell"

class OrderType(str, Enum):
    MARKET = "market"
    LIMIT = "limit"
    STOP_LIMIT = "stop_limit"

class TradeStatus(str, Enum):
    PENDING = "PENDING"      # Signal generated, not yet sent to exchange
    SUBMITTED = "SUBMITTED"  # Sent to exchange
    OPEN = "OPEN"            # Fill confirmed, position active
    CLOSED = "CLOSED"        # Position fully closed
    FAILED = "FAILED"        # Execution error
    CANCELED = "CANCELED"    # Signal canceled before execution

class RegimeType(str, Enum):
    TRENDING_UP = "trending_up"
    TRENDING_DOWN = "trending_down"
    RANGING = "ranging"
    VOLATILE = "volatile"
    UNKNOWN = "unknown"

# =============================================================================
# DATA MODELS
# =============================================================================

@dataclass
class BaseModel:
    """Base class with utility methods for all models."""
    def to_dict(self) -> Dict[str, Any]:
        """Convert dataclass to dictionary, handling Enums and Datetimes."""
        data = asdict(self)
        # Custom serialization for Enums and Datetimes could go here if needed
        return data

    @classmethod
    def from_dict(cls, data: Dict[str, Any]):
        """Helper to create object from dict (useful for DB loading)."""
        return cls(**data)

@dataclass
class MarketRegime(BaseModel):
    """
    Represents the current market context detected by the Analysis Pillar.
    Used to filter which strategies are allowed to trade.
    """
    pair: str
    timeframe: str
    regime_type: RegimeType
    volatility_score: float  # 0.0 to 100.0
    trend_strength: float    # 0.0 to 100.0
    timestamp: float = field(default_factory=lambda: datetime.now().timestamp())
    meta_data: Dict[str, Any] = field(default_factory=dict) # Extra info (e.g. specific indicators)

@dataclass
class Strategy(BaseModel):
    """
    Definition of a discovered strategy.
    """
    strategy_id: str
    name: str
    type: str # 'single_signal', 'mtf_mode_a', etc.
    version: str = "1.0"
    
    # Configuration
    timeframes: List[str] = field(default_factory=list) # e.g., ['1h', '15m']
    pairs: List[str] = field(default_factory=list)      # e.g., ['BTC_USDT']
    direction: TradeDirection = TradeDirection.LONG
    
    # Logic parameters (JSON serialized in DB)
    parameters: Dict[str, Any] = field(default_factory=dict)
    
    # Performance Stats (from Backtesting)
    win_rate: float = 0.0
    profit_factor: float = 0.0
    total_trades: int = 0
    regime_compatibility: List[RegimeType] = field(default_factory=list)

@dataclass
class Signal(BaseModel):
    """
    A trading instruction generated by the Signal Detector.
    This is the hand-off object between Strategy Pillar and Execution Pillar.
    """
    signal_id: str  # UUID
    strategy_id: str
    symbol: str     # e.g., 'btc_usdt' (Standardized format)
    direction: TradeDirection
    timestamp: float
    
    # Price Levels
    entry_price: float # The price at the moment the signal was generated
    stop_loss: float
    take_profit: float
    
    # Order Metadata
    order_type: OrderType = OrderType.MARKET
    limit_price: Optional[float] = None # Only if order_type is LIMIT
    
    # Risk Management
    quantity: Optional[float] = None # If calculated by strategy, else None (Risk Manager calculates)
    confidence: float = 0.0          # 0.0 to 1.0 (from ML model or rule confidence)
    
    # Context
    regime_at_signal: Optional[RegimeType] = None
    
    def get_side(self) -> OrderSide:
        """Converts Strategy Direction to Exchange Order Side."""
        if self.direction == TradeDirection.LONG:
            return OrderSide.BUY
        return OrderSide.SELL

@dataclass
class Trade(BaseModel):
    """
    Represents a live trade/position managed by the system.
    """
    trade_id: str # UUID
    signal_id: str
    strategy_id: str
    symbol: str
    direction: TradeDirection
    status: TradeStatus = TradeStatus.PENDING
    
    # Entry Details
    entry_time: float = 0.0
    entry_price: float = 0.0
    entry_order_id: Optional[str] = None
    quantity: float = 0.0
    
    # Risk Management (Live)
    stop_loss: float = 0.0
    take_profit: float = 0.0
    trailing_stop_activation: Optional[float] = None
    trailing_deviation: Optional[float] = None
    
    # Exit Details
    exit_time: Optional[float] = None
    exit_price: Optional[float] = None
    exit_order_id: Optional[str] = None
    exit_reason: str = "" # "TP", "SL", "Signal_Reverse", "Expired"
    
    # Outcome
    pnl_realized: float = 0.0
    pnl_percentage: float = 0.0
    fees: float = 0.0

    def is_active(self) -> bool:
        return self.status in [TradeStatus.PENDING, TradeStatus.SUBMITTED, TradeStatus.OPEN]